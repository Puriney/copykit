---
title: "CopyKit workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{  tutorial}
  %\VignetteEncoding{  UTF-8}
  %\VignetteEngine{  knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

  **CopyKit** provides a toolkit for the analysis of single-cell copy number datasets. It includes functions to read data from [Varbin](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4417119/) or [10X CNA datasets](https://www.10xgenomics.com/solutions/single-cell-cnv/).
  
  A common workflow with **CopyKit** consists in reading the dataset and using to filter the noisy cells out, clustering and plotting heatmaps for further analysis.

## Reading Varbin dataset

  Datasets generated with the varbin pipeline can be read with the function `readVarbinCNA()`. It creates an S4 class `scCNA` from the output directory of the copy number pipeline.
  `readVarbinCNA()` searches for the uber*.seg uber.bin and uber.ratio files in the provided directory.
  
  The scCNA object will contain 3 different assays: **segment ratios**, **ratios** and **bincounts** where each bin is row and each sample (cell) is a column.
  
  CopyKit stores the genomic ranges as a GRanges object containing chromosome number, start coordinate, end coordinate and absolute genomic position. 
  Each row represents the coordinates for one bin.
  
  It is possible to exclude the information from ChrY (important when working with XX samples) by setting the argument `remove_Y` to `TRUE`. Ex: `readVarbinCNA("~/path_to_varbin_output/", remove_Y = TRUE)`.

``` { eval = FALSE, warning=FALSE}
breast_tumor <- copykit::readVarbinCNA("~/path_to_varbin_output/")
```

```{ echo = FALSE, warning=FALSE}
dir = "/volumes/seq/projects/CNA_projects/DT_CNA/snap_frozen/Breast/TNBC/TN20/"
breast_tumor <- copykit::readVarbinCNA(dir, remove_Y = TRUE)
```

```{   }
breast_tumor
```

## Filtering cells.

Cells with low quality can be easily filtered with `filterCells()`.

`filterCells()` uses a k-nearest-neighbor approach to remove cells with random CNA profiles, largely due to noise.

**CopyKit** automatically outputs a heatmap so you can visually assess if the filtering performed as expected

It is possible to control how strict the filtering will be by changing the argument `resolution`. Ex: `filterCells(resolution = 0.9)`

```{   eval = FALSE, warning=FALSE, fig.height = 7 }
breast_tumor <- copykit::filterCells(breast_tumor,
                            resolution = 0.8)
```

```{  echo = FALSE, warning=FALSE, fig.height = 7 }
breast_tumor <- copykit::filterCells(breast_tumor,
                            resolution = 0.8,
                            n_threads = 40)
```

The information is store as metadata and can be accessed with `SummarizedExperiment::colData()`.

```{  warning=FALSE }
head(SummarizedExperiment::colData(breast_tumor))
```

## Non-linear dimension reduction

We can explore the sample organization at reduced dimensions with `runUmap()`. The goal is to explore the dataset for the presence of different subpopulations.
`runUmap()` stores the generated embedding into the `scCNA` object and can be accessed with `SingleCellExperiment::reducedDim(scCNA, 'umap')`.
**CopyKit** uses the package `uwot` to generate the umap embedding, this means that additional parameters that control the global or local structure to `runUmap()` can be passed on with the `...` argument. Ex: `copykit::runUmap(scCNA, min_dist = 0)`. To learn more on how those parameters can control global and local structure embedding visit the [Umap website](https://umap-learn.readthedocs.io/en/latest/clustering.html). For the full list of possible parameters check `?uwot::umap`.

```{  warning=FALSE}
breast_tumor <- copykit::runUmap(breast_tumor,
                                 min_dist = 0,
                                 n_neighbors = 30)
```

It is possivel to visualize the results with the function `copykit::plotUmap()`.

```{  warning=FALSE}
copykit::plotUmap(breast_tumor)
```

# Finding clusters

**CopyKit** uses a graph based approacht to search for clusters in the scCNA dataset. `copykit::findClusters()` builds an SNN graph of the k-nearest neighbors and attempts to find two different level of clustering: Major and minor subpopulations.
Major clusters are found by looking at the graph connected components, whereas minor clusters uses the Leiden algorithm to detect connected communities within the major clusters.
To run `copykit::findClusters()` you first need to run `copykit::runUmap()` since **CopyKit** applies the clustering on top of the UMAP embedding.

```{ warning=FALSE }
breast_tumor <- findClusters(breast_tumor)
```

Clustering information is stored as metadata and can be accessed with `SummarizedExperiment::colData(scCNA).

```{ warning=FALSE }
head(SummarizedExperiment::colData(breast_tumor))
```

`copykit::plotUmap()` can look for the cluster information and display it.

```{  warning=FALSE }
copykit::plotUmap(breast_tumor)
```

# Plotting heatmap

Plotting heatmap with **CopyKit** is done with the `plotHeatmap()` function. `plotHeatmap()` orders the cells according to a neighbor joining phylogenetic tree.
If cells were filtered it will automatically exclude the filtered out cells from the dataset. Otherwise the entire dataset is shown. `plotHeatmap()` also checks for the existence of cluster information and will automatically add it as an annotation to the heatmap.

```{ eval = FALSE, warning = FALSE, fig.height = 8}
copykit::plotHeatmap(breast_tumor)
```

```{ echo = FALSE, warning = FALSE, fig.height = 8}
copykit::plotHeatmap(breast_tumor, n_threads = 40)
```


