---
title: "CopyKit workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{r  tutorial}
  %\VignetteEncoding{r  UTF-8}
  %\VignetteEngine{r  knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

  **CopyKit** provides a toolkit for the analysis of single-cell copy number datasets. It includes functions to read data from [Varbin](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4417119/) or [10X CNA datasets](https://www.10xgenomics.com/solutions/single-cell-cnv/).
  
  A common workflow with **CopyKit** consists in reading the dataset and using to filter the noisy cells out, clustering and plotting heatmaps for further analysis.

## Reading Varbin dataset

  Datasets generated with the varbin pipeline can be read with the function `readVarbinCNA()`. It creates an S4 class `scCNA` from the output directory of the copy number pipeline.
  `readVarbinCNA()` searches for the uber*.seg uber.bin and uber.ratio files in the provided directory.
  
  The scCNA object will contain 3 different assays: **segment ratios**, **ratios** and **bincounts** where each bin is row and each sample (cell) is a column.
  
  CopyKit stores the genomic ranges as a GRanges object containing chromosome number, start coordinate, end coordinate and absolute genomic position. 
  Each row represents the coordinates for one bin.
  
  It is possible to exclude the information from ChrY (important when working with XX samples) by setting the argument `remove_Y` to `TRUE`. Ex: `readVarbinCNA("~/path_to_varbin_output/", remove_Y = TRUE)`.

``` {r eval = FALSE, warning=FALSE}
breast_tumor <- copykit::readVarbinCNA("~/path_to_varbin_output/")
```

```{r echo = FALSE, warning=FALSE}
suppressPackageStartupMessages(library(tidyverse))
library(reticulate)
use_python("/volumes/lab/users/dminussi/software/pythonenv/env/bin/python", required = T)
dir = "/volumes/seq/projects/CNA_projects/DT_CNA/snap_frozen/Breast/TNBC/TN20/"
breast_tumor <- copykit::readVarbinCNA(dir, remove_Y = TRUE)
```

```{r   }
breast_tumor
```

## Filtering cells.

Cells with low quality can be easily filtered with `filterCells()`.

`filterCells()` uses a k-nearest-neighbor approach to remove cells with random CNA profiles, largely due to noise.

By default, **CopyKit** automatically outputs a heatmap so you can visually assess if the filtering performed as expected, this however can be turned off by adding the argument `copykit::filterCells(scCNA, plot_heatmap = FALSE)`. Plotting the heatmap is a time consuming step due to distance calculations. CopyKit also allows for parallel processing of the distance calculations `copykit::filterCells()` with the argument `n_threads`.

To control how strict the filtering, change the argument `resolution`. Ex: `copykit::filterCells(resolution = 0.9)`

```{r eval = FALSE, warning=FALSE }
breast_tumor <- copykit::filterCells(breast_tumor,
                            resolution = 0.8)
```

```{r echo = FALSE, warning=FALSE}
breast_tumor <- copykit::filterCells(breast_tumor,
                            resolution = 0.8,
                            n_threads = 20,
                            plot_heatmap = TRUE)
```

The information is store as metadata and can be accessed with `SummarizedExperiment::colData()`.

```{r  warning=FALSE }
head(SummarizedExperiment::colData(breast_tumor))
```

If you are satisfied with the filtering you can simply subset the object based on the `SummarizedExperiment::colData(bt)$filtered` column

```{r warning=FALSE}
breast_tumor <- breast_tumor[,SummarizedExperiment::colData(breast_tumor)$filtered == "kept"]
```

After subsetting it is recommended to calculate a distance matrix that will be later passaged to functions such as `copykit::runPhylo()` or `copykit::plotHeatmap()`. This distance matrix is stored in the scCNA object and can be accessed with `copykit::distMat()`.

```{r warning=FALSE}
breast_tumor <- copykit::runDistMat(breast_tumor)
```

## Non-linear dimension reduction

We can explore the sample organization at reduced dimensions with `runUmap()`. The goal is to explore the dataset for the presence of different subpopulations.
`runUmap()` stores the generated embedding into the `scCNA` object and can be accessed with `SingleCellExperiment::reducedDim(scCNA, 'umap', withDimnames = FALSE)`.
**CopyKit** uses the package `uwot` to generate the umap embedding, this means that additional parameters that control the global or local structure to `runUmap()` can be passed on with the `...` argument. Ex: `copykit::runUmap(scCNA, min_dist = 0)`. To learn more on how those parameters can control global and local structure embedding visit the [Umap website](https://umap-learn.readthedocs.io/en/latest/clustering.html). For the full list of possible parameters check `?uwot::umap`.

```{r  warning=FALSE}
breast_tumor <- copykit::runUmap(breast_tumor,
                                 min_dist = 0,
                                 n_neighbors = 30)
```

It is possivel to visualize the results with the function `copykit::plotUmap()`.

```{r  warning=FALSE}
copykit::plotUmap(breast_tumor)
```

# Finding clusters

**CopyKit** uses a graph based approacht to search for clusters in the scCNA dataset. `copykit::findClusters()` builds an SNN graph of the k-nearest neighbors and attempts to find two different level of clustering: Major and minor subpopulations.
Major clusters are found by looking at the graph connected components, whereas minor clusters uses the Leiden algorithm to detect connected communities within the major clusters.
To run `copykit::findClusters()` you first need to run `copykit::runUmap()` since **CopyKit** applies the clustering on top of the UMAP embedding.

```{r warning=FALSE }
breast_tumor <- copykit::findClusters(breast_tumor)
```

Clustering information is stored as metadata and can be accessed with `SummarizedExperiment::colData(scCNA).

```{r warning=FALSE }
head(SummarizedExperiment::colData(breast_tumor))
```

`copykit::plotUmap()` can look for the cluster information and display it.

```{r  warning=FALSE }
copykit::plotUmap(breast_tumor)
```

# Running phylogenetic analysis
It is possible to run phylogenetic analysis with copykit by using the function `copykit::runPhylo()`. This function creates a distance based neighbor-joining tree that is stored within the scCNA object. You can access the resulting tree with `copykit::phylo()`

```{r}
breast_tumor <- copykit::runPhylo(breast_tumor)
```

Which can be easily visualized with
```{r warning=FALSE, fig.height=8}
plot(copykit::phylo(breast_tumor), cex = 0.1)
```

# Plotting heatmap

Plotting heatmap with **CopyKit** is done with the `plotHeatmap()` function. By default `plotHeatmap()` orders the cells according to a neighbor joining phylogenetic tree. `plotHeatmap()` also checks for the existence of cluster information and will automatically add it as an annotation to the heatmap.

```{r eval = FALSE, warning = FALSE, fig.height = 8}
copykit::plotHeatmap(breast_tumor)
```

```{r echo = FALSE, warning = FALSE, fig.height = 8}
copykit::plotHeatmap(breast_tumor)
```

It might be of interest to check for the heterogeneity in the number of copies across all the samples for different genes. **CopyKit** provides the function `copykit::geneCopyPlot()`.
```{r}
copykit::geneCopyPlot(breast_tumor,
                      genes = c("KRAS",
                                "MYC",
                                "TP53",
                                "ERBB2"))
```



