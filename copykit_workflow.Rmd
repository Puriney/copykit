---
title: "CopyKit Workflow"
output: github_document
---

  **CopyKit** provides a toolkit for the analysis of single-cell copy number datasets. It includes functions to read data from [Varbin](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4417119/) or [10X CNA datasets](https://www.10xgenomics.com/solutions/single-cell-cnv/).
  
  A common workflow with **CopyKit** consists in reading the dataset and using to filter the noisy cells out, clustering and plotting heatmaps for further analysis.


## Installation

You can install the development version of CopyKit from github with:

``` {}
devtools::install_github("navinlabcode/copykit")
```


```{r setup, include = FALSE}
library(copykit)
```

# Getting Started

  **CopyKit** provides a toolkit for the analysis of single-cell copy number datasets. It includes functions to read data from [Varbin](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4417119/) or [10X CNA datasets](https://www.10xgenomics.com/solutions/single-cell-cnv/).
  
  A common workflow with **CopyKit** consists in reading the dataset and using to filter the noisy cells out, clustering and plotting heatmaps for further analysis.

## Reading Varbin dataset

  Datasets generated with the varbin pipeline can be read with the function `readVarbinCNA()`. It creates an S4 class `scCNA` from the output directory of the copy number pipeline.
  `readVarbinCNA()` searches for the uber*.seg uber.bin and uber.ratio files in the provided directory.
  
  The scCNA object will contain 3 different assays: **segment ratios** (accessed with `copykit::segment_ratios()`), **ratios** (accessed with `copykit::ratios()`) and **bincounts** (accessed with `copykit::bin_counts()`) where each bin is row and each sample (cell) is a column.
  
  CopyKit stores the genomic ranges as a GRanges object containing chromosome number, start coordinate, end coordinate and absolute genomic position. 
  Each row represents the coordinates for one bin.
  
  It is possible to exclude the information from ChrY (important when working with XX samples) by setting the argument `remove_Y` to `TRUE`. Ex: `readVarbinCNA("~/path_to_varbin_output/", remove_Y = TRUE)`.

``` {r reading_data, eval = FALSE, warning=FALSE}
breast_tumor <- copykit::readVarbinCNA("~/path_to_varbin_output/")
```

```{r echo = FALSE, warning=FALSE}
library(reticulate)
use_python("/volumes/lab/users/dminussi/software/pythonenv/env/bin/python", required = T)
suppressPackageStartupMessages(library(tidyverse))
dir = "/volumes/seq/projects/CNA_projects/DT_CNA/snap_frozen/Breast/TNBC/TN20/"
breast_tumor <- copykit::readVarbinCNA(dir, remove_Y = TRUE)
```

```{r viewing_object}
breast_tumor
```

**CopyKit** stores the bin information within a rowRanges object, which can be accessed with `SummarizedExperiment::rowRanges()`:

```{r rowRanges}
SummarizedExperiment::rowRanges(breast_tumor)
```

## Obtain metrics
**Copykit** can provide some quick metrics about the data. That can be done with `copykit::runMetrics()`. It returns informative plots regarding the data

- Root Mean Squared Error: calculated from the distance of each bin to the segment. Which can be used as a way to evaluated the overdispersion and overall noise of the sample
- Total reads: Total read counts for each cell.
- PCR duplicates: Percentage of reads that are PCR duplicates for each cell.
- Breakpoint count: Counts the number of breakpoints per chromosome and sums it up for every cell.

All the information is stored as metadata and can be accessed with `SummarizedExperiment::colData()`.

```{r run_metrics}
breast_tumor <- copykit::runMetrics(breast_tumor)
```

After the information is calculated and saved in the scCNA object it can be visualized with `copykit::plotMetrics()`
```{r plot_metrics}
copykit::plotMetrics(breast_tumor)
```

`copykit::plotMetrics()` can color information according to any column available in the metadata.
```{r plot_metrics_label}
copykit::plotMetrics(breast_tumor,
                     label = "rmse")
```

You can also use the metrics in the metadata to filter the cells if desired.

## Filtering cells.

Cells with low quality can be easily filtered with `filterCells()`.

`filterCells()` uses a k-nearest-neighbor approach to remove cells with random CNA profiles, largely due to noise.

By default, **CopyKit** automatically outputs a heatmap so you can visually assess if the filtering performed as expected, this however can be turned off by adding the argument `filterCells(scCNA, plot_heatmap = FALSE)`. Plotting the heatmap is a time consuming step due to distance calculations. CopyKit also allows for parallel processing of the distance calculations `filterCells()` with the argument `n_threads`.

To control how strict the filtering, change the argument `resolution`. Ex: `filterCells(resolution = 0.9)`

```{r filtering_cells, eval = FALSE, warning=FALSE }
breast_tumor <- copykit::filterCells(breast_tumor,
                                     resolution = 0.8)
```

```{r filtering_cells_parallel, echo = FALSE, warning=FALSE}
breast_tumor <- copykit::filterCells(
  breast_tumor,
  resolution = 0.8,
  n_threads = 40,
  plot_heatmap = TRUE
)
```

The information is stored as metadata and can be accessed with `SummarizedExperiment::colData()`.

```{r  warning=FALSE }
head(SummarizedExperiment::colData(breast_tumor))
```

If you are satisfied with the filtering you can simply subset the object based on the `SummarizedExperiment::colData(bt)$filtered` column

```{r warning=FALSE}
breast_tumor <- breast_tumor[,SummarizedExperiment::colData(breast_tumor)$filtered == "kept"]
```

After subsetting it is recommended to calculate a distance matrix that will be later passaged to functions such as `runPhylo()` or `plotHeatmap()`. This distance matrix is stored in the scCNA object and can be accessed with `distMat()`.

```{r warning=FALSE}
breast_tumor <- copykit::runDistMat(breast_tumor)
```

## Non-linear dimension reduction

We can explore the sample organization at reduced dimensions with `runUmap()`. The goal is to explore the dataset for the presence of different subpopulations.
`runUmap()` stores the generated embedding into the `scCNA` object and can be accessed with `SingleCellExperiment::reducedDim(scCNA, 'umap', withDimnames = FALSE)`.
**CopyKit** uses the package `uwot` to generate the umap embedding, this means that additional parameters that control the global or local structure to `runUmap()` can be passed on with the `...` argument. Ex: `runUmap(scCNA, min_dist = 0)`. To learn more on how those parameters can control global and local structure embedding visit the [Umap website](https://umap-learn.readthedocs.io/en/latest/clustering.html). For the full list of possible parameters check `?uwot::umap`.

```{r  warning=FALSE}
breast_tumor <- copykit::runUmap(breast_tumor,
                                 min_dist = 0,
                                 n_neighbors = 30)
```

It is possivel to visualize the results with the function `plotUmap()`.

```{r  warning=FALSE}
plotUmap(breast_tumor)
```

`plotUmap()` can also be used to display information according to the metadata

For example on this sample we have information about different spatial locations, they are presented in the sample names with the prefix **S** followed by a number. We will use that and add that information to the metadata:

First we will add that information to the metadata
```{r}
# saving to a data.frame
spatial_info <- as.data.frame(SummarizedExperiment::colData(breast_tumor))
# removing the extra information
spatial_info$spatial_location <- stringr::str_extract(spatial_info$sample,
                                                   "(s[0-9]){1}")

SummarizedExperiment::colData(breast_tumor)$spatial_location <- spatial_info$spatial_location
```

Now we can plot that information using `plotUmap()`
```{r plot_umap_label}
plotUmap(breast_tumor, 
         label = "spatial_location")
```



# Finding clusters

**CopyKit** uses a graph based approacht to search for clusters in the scCNA dataset. `findClusters()` builds an SNN graph of the k-nearest neighbors and attempts to find two different level of clustering: Major and minor subpopulations.
Major clusters are found by looking at the graph connected components, whereas minor clusters uses the Leiden algorithm to detect connected communities within the major clusters.
To run `findClusters()` you first need `runUmap()`. **CopyKit** applies the clustering on top of the UMAP embedding.
Check `?copykit::findClusters()` for help on how to change the clustering parameters arguments.

```{r warning=FALSE }
breast_tumor <- copykit::findClusters(breast_tumor)
```

Clustering information is stored as metadata and can be accessed with `SummarizedExperiment::colData(scCNA).

```{r warning=FALSE }
head(SummarizedExperiment::colData(breast_tumor))
```

`plotUmap()` will display cluster information if it is available.

```{r  warning=FALSE }
plotUmap(breast_tumor)
```

# Running phylogenetic analysis
It is possible to run phylogenetic analysis with copykit by using the function `runPhylo()`. This function creates a distance based neighbor-joining tree that is stored within the scCNA object. You can access the resulting tree with `phylo()`

```{r}
breast_tumor <- copykit::runPhylo(breast_tumor)
```

Which can be easily visualized with
```{r warning=FALSE, fig.height=8}
plot(phylo(breast_tumor), cex = 0.1)
```

# Plotting heatmap

Plotting heatmap with **CopyKit** is done with the `plotHeatmap()` function. By default `plotHeatmap()` orders the cells according to a neighbor joining phylogenetic tree. `plotHeatmap()` also checks for the existence of cluster information and will automatically add it as an annotation to the heatmap if available.

```{r plotHeatmap, warning = FALSE}
copykit::plotHeatmap(breast_tumor)
```

# Plotting ratio plot

It is important to make sure that the segmentation is correctly following the data. In **CopyKit** that can be done with `copykit::plotRatioPlot()` for any given cell:
```{r plotRatioPlot, warning = FALSE}
copykit::plotRatioPlot(breast_tumor,
                       sample_name = "tn20_2_s2_c10_s394_r1_001")
```

`copykit::plotRatioPlot()` can also be used interactively. In this mode, **CopyKit** will plot a heatmap of the dataset. When the heatmap plotting is done you can click on the cell you would like to visualize the ratio plot of: 

```{r interactPlotRatioPlot, eval = FALSE}
copykit::plotRatioPlot(breast_tumor,
                       interactively = TRUE)
```
![plotRatioPlot interactive](docs/plotRatioPlotgif.gif)

# Visualize specific genes

It might be of interest to check for the heterogeneity in the number of copies across all the samples for different genes. **CopyKit** provides the function `geneCopyPlot()`.
```{r}
copykit::geneCopyPlot(breast_tumor,
                      genes = c("KRAS",
                                "MYC",
                                "TP53",
                                "ERBB2"))
```







